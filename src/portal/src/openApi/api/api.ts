/* tslint:disable */
/* eslint-disable */
/**
 * Pineapple
 * Pineapple
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * metadata to create an application instance
 * @export
 * @interface ApplicationConfig
 */
export interface ApplicationConfig {
  /**
   *
   * @type {string}
   * @memberof ApplicationConfig
   */
  url?: string;
  /**
   *
   * @type {object}
   * @memberof ApplicationConfig
   */
  answers?: object;
}
/**
 * application instance container
 * @export
 * @interface ApplicationInstanceContainer
 */
export interface ApplicationInstanceContainer {
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceContainer
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceContainer
   */
  image?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceContainer
   */
  state?: string;
  /**
   *
   * @type {Array<ApplicationInstanceContainerPorts>}
   * @memberof ApplicationInstanceContainer
   */
  ports?: Array<ApplicationInstanceContainerPorts>;
}
/**
 *
 * @export
 * @interface ApplicationInstanceContainerPorts
 */
export interface ApplicationInstanceContainerPorts {
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceContainerPorts
   */
  container_port?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceContainerPorts
   */
  protocol?: string;
}
/**
 * application instance event
 * @export
 * @interface ApplicationInstanceEvent
 */
export interface ApplicationInstanceEvent {
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceEvent
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceEvent
   */
  reason?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceEvent
   */
  age?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceEvent
   */
  from?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceEvent
   */
  message?: string;
}
/**
 * application instance
 * @export
 * @interface ApplicationInstanceMetadata
 */
export interface ApplicationInstanceMetadata {
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceMetadata
   */
  instance_name?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceMetadata
   */
  chart_name?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceMetadata
   */
  chart_version?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceMetadata
   */
  create_tm?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceMetadata
   */
  status?: string;
}
/**
 * application instance pod
 * @export
 * @interface ApplicationInstancePod
 */
export interface ApplicationInstancePod {
  /**
   *
   * @type {string}
   * @memberof ApplicationInstancePod
   */
  name?: string;
  /**
   *
   * @type {Array<ApplicationInstanceEvent>}
   * @memberof ApplicationInstancePod
   */
  events?: Array<ApplicationInstanceEvent>;
  /**
   *
   * @type {string}
   * @memberof ApplicationInstancePod
   */
  state?: string;
  /**
   *
   * @type {Array<ApplicationInstanceContainer>}
   * @memberof ApplicationInstancePod
   */
  containers?: Array<ApplicationInstanceContainer>;
  /**
   *
   * @type {string}
   * @memberof ApplicationInstancePod
   */
  create_tm?: string;
}
/**
 * application instance pod list
 * @export
 * @interface ApplicationInstancePodList
 */
export interface ApplicationInstancePodList {
  /**
   *
   * @type {number}
   * @memberof ApplicationInstancePodList
   */
  total?: number;
  /**
   *
   * @type {Array<ApplicationInstancePod>}
   * @memberof ApplicationInstancePodList
   */
  item?: Array<ApplicationInstancePod>;
}
/**
 * application instance pod
 * @export
 * @interface ApplicationInstanceService
 */
export interface ApplicationInstanceService {
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceService
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceService
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceService
   */
  cluster_ip?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ApplicationInstanceService
   */
  external_ips?: Array<string>;
  /**
   *
   * @type {Array<ApplicationInstanceServicePorts>}
   * @memberof ApplicationInstanceService
   */
  ports?: Array<ApplicationInstanceServicePorts>;
}
/**
 * application instance service list
 * @export
 * @interface ApplicationInstanceServiceList
 */
export interface ApplicationInstanceServiceList {
  /**
   *
   * @type {number}
   * @memberof ApplicationInstanceServiceList
   */
  total?: number;
  /**
   *
   * @type {Array<ApplicationInstanceService>}
   * @memberof ApplicationInstanceServiceList
   */
  item?: Array<ApplicationInstanceService>;
}
/**
 *
 * @export
 * @interface ApplicationInstanceServicePorts
 */
export interface ApplicationInstanceServicePorts {
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceServicePorts
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceServicePorts
   */
  port?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceServicePorts
   */
  node_port?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationInstanceServicePorts
   */
  protocol?: string;
}
/**
 * application instance list
 * @export
 * @interface ApplicationList
 */
export interface ApplicationList {
  /**
   *
   * @type {number}
   * @memberof ApplicationList
   */
  total?: number;
  /**
   *
   * @type {Array<ApplicationInstanceMetadata>}
   * @memberof ApplicationList
   */
  item?: Array<ApplicationInstanceMetadata>;
}
/**
 * chart
 * @export
 * @interface Chart
 */
export interface Chart {
  /**
   *
   * @type {ChartMetadata}
   * @memberof Chart
   */
  metadata?: ChartMetadata;
  /**
   * chart files
   * @type {{ [key: string]: string; }}
   * @memberof Chart
   */
  files?: { [key: string]: string };
  /**
   *
   * @type {Array<string>}
   * @memberof Chart
   */
  version_list?: Array<string>;
}
/**
 * chart repo category
 * @export
 * @enum {string}
 */
export enum ChartCategory {
  PublicOfficial = 'public-official',
  PublicPractical = 'public-practical',
  PublicCommunity = 'public-community',
  Private = 'private',
}

/**
 * chart metadata list
 * @export
 * @interface ChartMetaDataList
 */
export interface ChartMetaDataList {
  /**
   *
   * @type {Array<ChartMetadata>}
   * @memberof ChartMetaDataList
   */
  items?: Array<ChartMetadata>;
}
/**
 * chart metadata
 * @export
 * @interface ChartMetadata
 */
export interface ChartMetadata {
  /**
   *
   * @type {string}
   * @memberof ChartMetadata
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ChartMetadata
   */
  showName?: string;
  /**
   *
   * @type {string}
   * @memberof ChartMetadata
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ChartMetadata
   */
  version?: string;
  /**
   *
   * @type {string}
   * @memberof ChartMetadata
   */
  url?: string;
  /**
   *
   * @type {string}
   * @memberof ChartMetadata
   */
  icon_link?: string;
  /**
   *
   * @type {ChartCategory}
   * @memberof ChartMetadata
   */
  category?: ChartCategory;
}
/**
 *
 * @export
 * @interface CompetitionInfo
 */
export interface CompetitionInfo {
  /**
   *
   * @type {string}
   * @memberof CompetitionInfo
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof CompetitionInfo
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof CompetitionInfo
   */
  beginning?: string;
  /**
   *
   * @type {string}
   * @memberof CompetitionInfo
   */
  deadline?: string;
  /**
   *
   * @type {boolean}
   * @memberof CompetitionInfo
   */
  avl?: boolean;
  /**
   *
   * @type {Array<ComputeUnitSpec>}
   * @memberof CompetitionInfo
   */
  computingResource?: Array<ComputeUnitSpec>;
}
/**
 * compute unit spec
 * @export
 * @interface ComputeUnitSpec
 */
export interface ComputeUnitSpec {
  /**
   * compute unit spec
   * @type {string}
   * @memberof ComputeUnitSpec
   */
  name?: string;
  /**
   * compute unit name
   * @type {string}
   * @memberof ComputeUnitSpec
   */
  id?: string;
  /**
   * price
   * @type {number}
   * @memberof ComputeUnitSpec
   */
  price?: number;
  /**
   *
   * @type {string}
   * @memberof ComputeUnitSpec
   */
  description?: string;
}
/**
 * private or public
 * @export
 * @enum {string}
 */
export enum DomainType {
  Public = 'public',
  Private = 'private',
}

/**
 * environment configuration
 * @export
 * @interface EnvironmentConfig
 */
export interface EnvironmentConfig {
  /**
   *
   * @type {ImageConfig}
   * @memberof EnvironmentConfig
   */
  image?: ImageConfig;
  /**
   *
   * @type {Array<StorageMapping>}
   * @memberof EnvironmentConfig
   */
  mounts?: Array<StorageMapping>;
  /**
   * compute unit name
   * @type {string}
   * @memberof EnvironmentConfig
   */
  compute_unit?: string;
  /**
   *
   * @type {EnvironmentConfigSsh}
   * @memberof EnvironmentConfig
   */
  ssh?: EnvironmentConfigSsh;
  /**
   *
   * @type {EnvironmentConfigJupyter}
   * @memberof EnvironmentConfig
   */
  jupyter?: EnvironmentConfigJupyter;
}
/**
 *
 * @export
 * @interface EnvironmentConfigJupyter
 */
export interface EnvironmentConfigJupyter {
  /**
   *
   * @type {boolean}
   * @memberof EnvironmentConfigJupyter
   */
  enable?: boolean;
  /**
   *
   * @type {string}
   * @memberof EnvironmentConfigJupyter
   */
  token?: string;
}
/**
 *
 * @export
 * @interface EnvironmentConfigSsh
 */
export interface EnvironmentConfigSsh {
  /**
   *
   * @type {boolean}
   * @memberof EnvironmentConfigSsh
   */
  enable?: boolean;
  /**
   *
   * @type {string}
   * @memberof EnvironmentConfigSsh
   */
  id_rsa_pub?: string;
}
/**
 * environment runtime information
 * @export
 * @interface EnvironmentRuntimeInfo
 */
export interface EnvironmentRuntimeInfo {
  /**
   *
   * @type {EnvironmentRuntimeStaticInfo}
   * @memberof EnvironmentRuntimeInfo
   */
  staticInfo?: EnvironmentRuntimeStaticInfo;
  /**
   *
   * @type {EnvironmentState}
   * @memberof EnvironmentRuntimeInfo
   */
  state?: EnvironmentState;
  /**
   *
   * @type {EnvironmentRuntimeSshInfo}
   * @memberof EnvironmentRuntimeInfo
   */
  sshInfo?: EnvironmentRuntimeSshInfo;
  /**
   *
   * @type {string}
   * @memberof EnvironmentRuntimeInfo
   */
  pod_name?: string;
}
/**
 * environment runtime information list
 * @export
 * @interface EnvironmentRuntimeInfos
 */
export interface EnvironmentRuntimeInfos {
  /**
   *
   * @type {number}
   * @memberof EnvironmentRuntimeInfos
   */
  total?: number;
  /**
   *
   * @type {Array<EnvironmentRuntimeInfo>}
   * @memberof EnvironmentRuntimeInfos
   */
  item?: Array<EnvironmentRuntimeInfo>;
}
/**
 * environment runtime ssh information
 * @export
 * @interface EnvironmentRuntimeSshInfo
 */
export interface EnvironmentRuntimeSshInfo {
  /**
   *
   * @type {string}
   * @memberof EnvironmentRuntimeSshInfo
   */
  ssh_ip?: string;
  /**
   *
   * @type {string}
   * @memberof EnvironmentRuntimeSshInfo
   */
  ssh_port?: string;
}
/**
 * environment runtime static information
 * @export
 * @interface EnvironmentRuntimeStaticInfo
 */
export interface EnvironmentRuntimeStaticInfo {
  /**
   * environment name
   * @type {string}
   * @memberof EnvironmentRuntimeStaticInfo
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof EnvironmentRuntimeStaticInfo
   */
  create_tm?: string;
  /**
   *
   * @type {EnvironmentConfig}
   * @memberof EnvironmentRuntimeStaticInfo
   */
  environmentConfig?: EnvironmentConfig;
  /**
   *
   * @type {string}
   * @memberof EnvironmentRuntimeStaticInfo
   */
  notebook_url?: string;
  /**
   *
   * @type {string}
   * @memberof EnvironmentRuntimeStaticInfo
   */
  description?: string;
}
/**
 * environment state
 * @export
 * @enum {string}
 */
export enum EnvironmentState {
  Pending = 'Pending',
  Running = 'Running',
  Succeeded = 'Succeeded',
  Failed = 'Failed',
  Unknown = 'Unknown',
}

/**
 * file or directory info
 * @export
 * @interface FileInfo
 */
export interface FileInfo {
  /**
   *
   * @type {string}
   * @memberof FileInfo
   */
  name?: string;
  /**
   *
   * @type {boolean}
   * @memberof FileInfo
   */
  is_dir?: boolean;
  /**
   *
   * @type {string}
   * @memberof FileInfo
   */
  size?: string;
  /**
   *
   * @type {string}
   * @memberof FileInfo
   */
  modification_time?: string;
}
/**
 * image configuration
 * @export
 * @interface ImageConfig
 */
export interface ImageConfig {
  /**
   *
   * @type {string}
   * @memberof ImageConfig
   */
  repo?: string;
  /**
   *
   * @type {string}
   * @memberof ImageConfig
   */
  tag?: string;
  /**
   *
   * @type {string}
   * @memberof ImageConfig
   */
  source?: string;
}
/**
 * import image info
 * @export
 * @interface ImageImportingInfo
 */
export interface ImageImportingInfo {
  /**
   *
   * @type {ImageRegistryInfo}
   * @memberof ImageImportingInfo
   */
  registry?: ImageRegistryInfo;
  /**
   * image repo
   * @type {string}
   * @memberof ImageImportingInfo
   */
  repo?: string;
  /**
   * image tag
   * @type {string}
   * @memberof ImageImportingInfo
   */
  tag?: string;
  /**
   *
   * @type {string}
   * @memberof ImageImportingInfo
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof ImageImportingInfo
   */
  start_time?: string;
  /**
   *
   * @type {string}
   * @memberof ImageImportingInfo
   */
  end_time?: string;
  /**
   * image importing ID
   * @type {number}
   * @memberof ImageImportingInfo
   */
  importing_id?: number;
}
/**
 * image info
 * @export
 * @interface ImageInfo
 */
export interface ImageInfo {
  /**
   * image repo
   * @type {string}
   * @memberof ImageInfo
   */
  repo?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ImageInfo
   */
  tags?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ImageInfo
   */
  size?: string;
  /**
   *
   * @type {string}
   * @memberof ImageInfo
   */
  importing_time?: string;
}
/**
 * image registry info
 * @export
 * @interface ImageRegistryInfo
 */
export interface ImageRegistryInfo {
  /**
   *
   * @type {string}
   * @memberof ImageRegistryInfo
   */
  url?: string;
  /**
   *
   * @type {number}
   * @memberof ImageRegistryInfo
   */
  id?: number;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse200
   */
  notes?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
  /**
   * release name
   * @type {string}
   * @memberof InlineResponse2001
   */
  name?: string;
  /**
   * short description excluding newlines
   * @type {string}
   * @memberof InlineResponse2001
   */
  summary?: string;
  /**
   * long description including newlines
   * @type {string}
   * @memberof InlineResponse2001
   */
  description?: string;
  /**
   *
   * @type {Array<KubernetesPod>}
   * @memberof InlineResponse2001
   */
  pods?: Array<KubernetesPod>;
  /**
   *
   * @type {Array<KubernetesService>}
   * @memberof InlineResponse2001
   */
  services?: Array<KubernetesService>;
}
/**
 *
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
  /**
   *
   * @type {object}
   * @memberof InlineResponse400
   */
  content?: object;
  /**
   *
   * @type {string}
   * @memberof InlineResponse400
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse400
   */
  type?: string;
}
/**
 * container schema
 * @export
 * @interface KubernetesContainer
 */
export interface KubernetesContainer {
  /**
   * container name
   * @type {string}
   * @memberof KubernetesContainer
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof KubernetesContainer
   */
  state?: string;
  /**
   * image name
   * @type {string}
   * @memberof KubernetesContainer
   */
  image?: string;
}
/**
 * pod schema
 * @export
 * @interface KubernetesPod
 */
export interface KubernetesPod {
  /**
   * pod name
   * @type {string}
   * @memberof KubernetesPod
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof KubernetesPod
   */
  ip?: string;
  /**
   *
   * @type {string}
   * @memberof KubernetesPod
   */
  state?: string;
  /**
   * compute unit name
   * @type {string}
   * @memberof KubernetesPod
   */
  compute_unit?: string;
  /**
   *
   * @type {Array<KubernetesContainer>}
   * @memberof KubernetesPod
   */
  containers?: Array<KubernetesContainer>;
}
/**
 * service schema
 * @export
 * @interface KubernetesService
 */
export interface KubernetesService {
  /**
   * service name
   * @type {string}
   * @memberof KubernetesService
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof KubernetesService
   */
  cluster_ip?: string;
  /**
   *
   * @type {string}
   * @memberof KubernetesService
   */
  port?: string;
  /**
   *
   * @type {string}
   * @memberof KubernetesService
   */
  node_port?: string;
}
/**
 * user repo info
 * @export
 * @interface ProjectUserInfo
 */
export interface ProjectUserInfo {
  /**
   *
   * @type {number}
   * @memberof ProjectUserInfo
   */
  image_count?: number;
}
/**
 * metadata to create a release
 * @export
 * @interface ReleaseCreateConfig
 */
export interface ReleaseCreateConfig {
  /**
   * release name
   * @type {string}
   * @memberof ReleaseCreateConfig
   */
  name?: string;
  /**
   * chart name
   * @type {string}
   * @memberof ReleaseCreateConfig
   */
  chart_name?: string;
  /**
   * utf-8 encoded value.yaml file
   * @type {any}
   * @memberof ReleaseCreateConfig
   */
  value_encode?: any;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum ReleaseState {
  Running = 'running',
  Stopped = 'stopped',
  Finished = 'finished',
}

/**
 * service to expose
 * @export
 * @interface ServiceExpose
 */
export interface ServiceExpose {
  /**
   * service name
   * @type {string}
   * @memberof ServiceExpose
   */
  name?: string;
  /**
   * port
   * @type {number}
   * @memberof ServiceExpose
   */
  port?: number;
}
/**
 * storage mapping
 * @export
 * @interface StorageMapping
 */
export interface StorageMapping {
  /**
   * relative path to user storage path
   * @type {string}
   * @memberof StorageMapping
   */
  subpath?: string;
  /**
   * absolute path to container filesystem path
   * @type {string}
   * @memberof StorageMapping
   */
  mountpath?: string;
}
/**
 *
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
  /**
   *
   * @type {string}
   * @memberof UserInfo
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof UserInfo
   */
  balance?: number;
}
/**
 * user login information
 * @export
 * @interface UserLoginInfo
 */
export interface UserLoginInfo {
  /**
   * user name
   * @type {string}
   * @memberof UserLoginInfo
   */
  username: string;
  /**
   * password
   * @type {string}
   * @memberof UserLoginInfo
   */
  password: string;
}
/**
 *
 * @export
 * @interface UserRefreshToken
 */
export interface UserRefreshToken {
  /**
   *
   * @type {string}
   * @memberof UserRefreshToken
   */
  refresh_token: string;
}
/**
 * user register information
 * @export
 * @interface UserRegisterInfo
 */
export interface UserRegisterInfo {
  /**
   *
   * @type {string}
   * @memberof UserRegisterInfo
   */
  code: string;
  /**
   * user email
   * @type {string}
   * @memberof UserRegisterInfo
   */
  email: string;
  /**
   * user name
   * @type {string}
   * @memberof UserRegisterInfo
   */
  username: string;
  /**
   * password
   * @type {string}
   * @memberof UserRegisterInfo
   */
  password: string;
}
/**
 *
 * @export
 * @interface UserTaskInfo
 */
export interface UserTaskInfo {
  /**
   * compute unit name
   * @type {string}
   * @memberof UserTaskInfo
   */
  compute_unit?: string;
  /**
   *
   * @type {number}
   * @memberof UserTaskInfo
   */
  number?: number;
  /**
   *
   * @type {number}
   * @memberof UserTaskInfo
   */
  price?: number;
}
/**
 *
 * @export
 * @interface UserTasksInfo
 */
export interface UserTasksInfo {
  /**
   *
   * @type {number}
   * @memberof UserTasksInfo
   */
  task_num?: number;
  /**
   *
   * @type {Array<UserTaskInfo>}
   * @memberof UserTasksInfo
   */
  task_list?: Array<UserTaskInfo>;
}

/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create an app
     * @param {string} name application name
     * @param {ApplicationConfig} [applicationConfig]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApplication: async (
      name: string,
      applicationConfig?: ApplicationConfig,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('createApplication', 'name', name);
      const localVarPath = `/applications/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        applicationConfig,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete an application instance
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApplication: async (name: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deleteApplication', 'name', name);
      const localVarPath = `/applications/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get application list
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationList: async (
      offset?: number,
      limit?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/applications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a application metadata
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationMetadata: async (name: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getApplicationMetadata', 'name', name);
      const localVarPath = `/applications/{name}/metadata`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets application notes
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationNotes: async (name: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getApplicationNotes', 'name', name);
      const localVarPath = `/applications/{name}/notes`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a application pods
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationPods: async (name: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getApplicationPods', 'name', name);
      const localVarPath = `/applications/{name}/pods`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a application services
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationServices: async (name: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getApplicationServices', 'name', name);
      const localVarPath = `/applications/{name}/services`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create an app
     * @param {string} name application name
     * @param {ApplicationConfig} [applicationConfig]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createApplication(
      name: string,
      applicationConfig?: ApplicationConfig,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(
        name,
        applicationConfig,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete an application instance
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteApplication(
      name: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(name, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get application list
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApplicationList(
      offset?: number,
      limit?: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationList(
        offset,
        limit,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a application metadata
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApplicationMetadata(
      name: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationInstanceMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationMetadata(
        name,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets application notes
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApplicationNotes(
      name: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationNotes(name, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a application pods
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApplicationPods(
      name: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationInstancePodList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationPods(name, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a application services
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApplicationServices(
      name: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationInstanceServiceList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationServices(
        name,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApplicationsApiFp(configuration);
  return {
    /**
     *
     * @summary Create an app
     * @param {string} name application name
     * @param {ApplicationConfig} [applicationConfig]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApplication(
      name: string,
      applicationConfig?: ApplicationConfig,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .createApplication(name, applicationConfig, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete an application instance
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApplication(name: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteApplication(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get application list
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationList(
      offset?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<ApplicationList> {
      return localVarFp
        .getApplicationList(offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a application metadata
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationMetadata(name: string, options?: any): AxiosPromise<ApplicationInstanceMetadata> {
      return localVarFp
        .getApplicationMetadata(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets application notes
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationNotes(name: string, options?: any): AxiosPromise<InlineResponse200> {
      return localVarFp
        .getApplicationNotes(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a application pods
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationPods(name: string, options?: any): AxiosPromise<ApplicationInstancePodList> {
      return localVarFp
        .getApplicationPods(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a application services
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationServices(
      name: string,
      options?: any,
    ): AxiosPromise<ApplicationInstanceServiceList> {
      return localVarFp
        .getApplicationServices(name, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
  /**
   *
   * @summary Create an app
   * @param {string} name application name
   * @param {ApplicationConfig} [applicationConfig]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public createApplication(name: string, applicationConfig?: ApplicationConfig, options?: any) {
    return ApplicationsApiFp(this.configuration)
      .createApplication(name, applicationConfig, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete an application instance
   * @param {string} name application name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public deleteApplication(name: string, options?: any) {
    return ApplicationsApiFp(this.configuration)
      .deleteApplication(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get application list
   * @param {number} [offset] The number of items to skip before starting to collect the result set
   * @param {number} [limit] The numbers of items to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public getApplicationList(offset?: number, limit?: number, options?: any) {
    return ApplicationsApiFp(this.configuration)
      .getApplicationList(offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a application metadata
   * @param {string} name application name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public getApplicationMetadata(name: string, options?: any) {
    return ApplicationsApiFp(this.configuration)
      .getApplicationMetadata(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets application notes
   * @param {string} name application name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public getApplicationNotes(name: string, options?: any) {
    return ApplicationsApiFp(this.configuration)
      .getApplicationNotes(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a application pods
   * @param {string} name application name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public getApplicationPods(name: string, options?: any) {
    return ApplicationsApiFp(this.configuration)
      .getApplicationPods(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a application services
   * @param {string} name application name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public getApplicationServices(name: string, options?: any) {
    return ApplicationsApiFp(this.configuration)
      .getApplicationServices(name, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AppstoreApi - axios parameter creator
 * @export
 */
export const AppstoreApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get a chart
     * @param {ChartCategory} category chart repo
     * @param {string} name chart name
     * @param {string} version chart version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppstoreChart: async (
      category: ChartCategory,
      name: string,
      version: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'category' is not null or undefined
      assertParamExists('getAppstoreChart', 'category', category);
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getAppstoreChart', 'name', name);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('getAppstoreChart', 'version', version);
      const localVarPath = `/appstore/charts/{category}/{name}/{version}`
        .replace(`{${'category'}}`, encodeURIComponent(String(category)))
        .replace(`{${'name'}}`, encodeURIComponent(String(name)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get chart list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppstoreChartList: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/appstore/charts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Upload chart
     * @param {ChartCategory} category chart repo
     * @param {any} [file] file type for upload and Download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadChart: async (
      category: ChartCategory,
      file?: any,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'category' is not null or undefined
      assertParamExists('uploadChart', 'category', category);
      const localVarPath = `/appstore/charts/{category}`.replace(
        `{${'category'}}`,
        encodeURIComponent(String(category)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (file !== undefined) {
        localVarFormParams.append('file', file as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AppstoreApi - functional programming interface
 * @export
 */
export const AppstoreApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AppstoreApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get a chart
     * @param {ChartCategory} category chart repo
     * @param {string} name chart name
     * @param {string} version chart version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAppstoreChart(
      category: ChartCategory,
      name: string,
      version: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chart>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAppstoreChart(
        category,
        name,
        version,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get chart list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAppstoreChartList(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartMetaDataList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAppstoreChartList(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Upload chart
     * @param {ChartCategory} category chart repo
     * @param {any} [file] file type for upload and Download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadChart(
      category: ChartCategory,
      file?: any,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadChart(
        category,
        file,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * AppstoreApi - factory interface
 * @export
 */
export const AppstoreApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AppstoreApiFp(configuration);
  return {
    /**
     *
     * @summary Get a chart
     * @param {ChartCategory} category chart repo
     * @param {string} name chart name
     * @param {string} version chart version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppstoreChart(
      category: ChartCategory,
      name: string,
      version: string,
      options?: any,
    ): AxiosPromise<Chart> {
      return localVarFp
        .getAppstoreChart(category, name, version, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get chart list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppstoreChartList(options?: any): AxiosPromise<ChartMetaDataList> {
      return localVarFp.getAppstoreChartList(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Upload chart
     * @param {ChartCategory} category chart repo
     * @param {any} [file] file type for upload and Download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadChart(category: ChartCategory, file?: any, options?: any): AxiosPromise<void> {
      return localVarFp
        .uploadChart(category, file, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AppstoreApi - object-oriented interface
 * @export
 * @class AppstoreApi
 * @extends {BaseAPI}
 */
export class AppstoreApi extends BaseAPI {
  /**
   *
   * @summary Get a chart
   * @param {ChartCategory} category chart repo
   * @param {string} name chart name
   * @param {string} version chart version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppstoreApi
   */
  public getAppstoreChart(category: ChartCategory, name: string, version: string, options?: any) {
    return AppstoreApiFp(this.configuration)
      .getAppstoreChart(category, name, version, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get chart list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppstoreApi
   */
  public getAppstoreChartList(options?: any) {
    return AppstoreApiFp(this.configuration)
      .getAppstoreChartList(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Upload chart
   * @param {ChartCategory} category chart repo
   * @param {any} [file] file type for upload and Download
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppstoreApi
   */
  public uploadChart(category: ChartCategory, file?: any, options?: any) {
    return AppstoreApiFp(this.configuration)
      .uploadChart(category, file, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CompetitionApi - axios parameter creator
 * @export
 */
export const CompetitionApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary check joined competition
     * @param {string} competitionID computition id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    competitionCompetitionIDGet: async (
      competitionID: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'competitionID' is not null or undefined
      assertParamExists('competitionCompetitionIDGet', 'competitionID', competitionID);
      const localVarPath = `/competition/{competitionID}`.replace(
        `{${'competitionID'}}`,
        encodeURIComponent(String(competitionID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get invitation number in a competition
     * @param {string} competitionID computition id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    competitionCompetitionIDInvitationGet: async (
      competitionID: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'competitionID' is not null or undefined
      assertParamExists('competitionCompetitionIDInvitationGet', 'competitionID', competitionID);
      const localVarPath = `/competition/{competitionID}/invitation`.replace(
        `{${'competitionID'}}`,
        encodeURIComponent(String(competitionID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary join competition
     * @param {string} competitionID computition id
     * @param {string} [inviter] inviter id
     * @param {{ [key: string]: string; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    competitionCompetitionIDPost: async (
      competitionID: string,
      inviter?: string,
      requestBody?: { [key: string]: string },
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'competitionID' is not null or undefined
      assertParamExists('competitionCompetitionIDPost', 'competitionID', competitionID);
      const localVarPath = `/competition/{competitionID}`.replace(
        `{${'competitionID'}}`,
        encodeURIComponent(String(competitionID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (inviter !== undefined) {
        localVarQueryParameter['inviter'] = inviter;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary list competition
     * @param {string} [beginning]
     * @param {string} [end]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    competitionGet: async (
      beginning?: string,
      end?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/competition`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (beginning !== undefined) {
        localVarQueryParameter['beginning'] =
          (beginning as any) instanceof Date ? (beginning as any).toISOString() : beginning;
      }

      if (end !== undefined) {
        localVarQueryParameter['end'] =
          (end as any) instanceof Date ? (end as any).toISOString() : end;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CompetitionApi - functional programming interface
 * @export
 */
export const CompetitionApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CompetitionApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary check joined competition
     * @param {string} competitionID computition id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async competitionCompetitionIDGet(
      competitionID: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.competitionCompetitionIDGet(
        competitionID,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get invitation number in a competition
     * @param {string} competitionID computition id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async competitionCompetitionIDInvitationGet(
      competitionID: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.competitionCompetitionIDInvitationGet(
        competitionID,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary join competition
     * @param {string} competitionID computition id
     * @param {string} [inviter] inviter id
     * @param {{ [key: string]: string; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async competitionCompetitionIDPost(
      competitionID: string,
      inviter?: string,
      requestBody?: { [key: string]: string },
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.competitionCompetitionIDPost(
        competitionID,
        inviter,
        requestBody,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary list competition
     * @param {string} [beginning]
     * @param {string} [end]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async competitionGet(
      beginning?: string,
      end?: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CompetitionInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.competitionGet(
        beginning,
        end,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * CompetitionApi - factory interface
 * @export
 */
export const CompetitionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = CompetitionApiFp(configuration);
  return {
    /**
     *
     * @summary check joined competition
     * @param {string} competitionID computition id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    competitionCompetitionIDGet(competitionID: string, options?: any): AxiosPromise<boolean> {
      return localVarFp
        .competitionCompetitionIDGet(competitionID, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary get invitation number in a competition
     * @param {string} competitionID computition id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    competitionCompetitionIDInvitationGet(
      competitionID: string,
      options?: any,
    ): AxiosPromise<number> {
      return localVarFp
        .competitionCompetitionIDInvitationGet(competitionID, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary join competition
     * @param {string} competitionID computition id
     * @param {string} [inviter] inviter id
     * @param {{ [key: string]: string; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    competitionCompetitionIDPost(
      competitionID: string,
      inviter?: string,
      requestBody?: { [key: string]: string },
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .competitionCompetitionIDPost(competitionID, inviter, requestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary list competition
     * @param {string} [beginning]
     * @param {string} [end]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    competitionGet(
      beginning?: string,
      end?: string,
      options?: any,
    ): AxiosPromise<Array<CompetitionInfo>> {
      return localVarFp
        .competitionGet(beginning, end, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CompetitionApi - object-oriented interface
 * @export
 * @class CompetitionApi
 * @extends {BaseAPI}
 */
export class CompetitionApi extends BaseAPI {
  /**
   *
   * @summary check joined competition
   * @param {string} competitionID computition id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompetitionApi
   */
  public competitionCompetitionIDGet(competitionID: string, options?: any) {
    return CompetitionApiFp(this.configuration)
      .competitionCompetitionIDGet(competitionID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get invitation number in a competition
   * @param {string} competitionID computition id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompetitionApi
   */
  public competitionCompetitionIDInvitationGet(competitionID: string, options?: any) {
    return CompetitionApiFp(this.configuration)
      .competitionCompetitionIDInvitationGet(competitionID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary join competition
   * @param {string} competitionID computition id
   * @param {string} [inviter] inviter id
   * @param {{ [key: string]: string; }} [requestBody]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompetitionApi
   */
  public competitionCompetitionIDPost(
    competitionID: string,
    inviter?: string,
    requestBody?: { [key: string]: string },
    options?: any,
  ) {
    return CompetitionApiFp(this.configuration)
      .competitionCompetitionIDPost(competitionID, inviter, requestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary list competition
   * @param {string} [beginning]
   * @param {string} [end]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompetitionApi
   */
  public competitionGet(beginning?: string, end?: string, options?: any) {
    return CompetitionApiFp(this.configuration)
      .competitionGet(beginning, end, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ComputingResourceApi - axios parameter creator
 * @export
 */
export const ComputingResourceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get computing unit specifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getComputingUnitSpecs: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/computing_resource/specs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ComputingResourceApi - functional programming interface
 * @export
 */
export const ComputingResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ComputingResourceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get computing unit specifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getComputingUnitSpecs(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ComputeUnitSpec>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getComputingUnitSpecs(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * ComputingResourceApi - factory interface
 * @export
 */
export const ComputingResourceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ComputingResourceApiFp(configuration);
  return {
    /**
     *
     * @summary Get computing unit specifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getComputingUnitSpecs(options?: any): AxiosPromise<Array<ComputeUnitSpec>> {
      return localVarFp.getComputingUnitSpecs(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * ComputingResourceApi - object-oriented interface
 * @export
 * @class ComputingResourceApi
 * @extends {BaseAPI}
 */
export class ComputingResourceApi extends BaseAPI {
  /**
   *
   * @summary Get computing unit specifications
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComputingResourceApi
   */
  public getComputingUnitSpecs(options?: any) {
    return ComputingResourceApiFp(this.configuration)
      .getComputingUnitSpecs(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EnvironmentsApi - axios parameter creator
 * @export
 */
export const EnvironmentsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create an environment
     * @param {string} name Name of environment
     * @param {EnvironmentConfig} [environmentConfig] Information about creating an environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEnvironment: async (
      name: string,
      environmentConfig?: EnvironmentConfig,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('createEnvironment', 'name', name);
      const localVarPath = `/environments/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        environmentConfig,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete an environment
     * @param {string} name Name of environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEnvironment: async (name: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deleteEnvironment', 'name', name);
      const localVarPath = `/environments/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets environment
     * @param {string} name Name of environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironment: async (name: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getEnvironment', 'name', name);
      const localVarPath = `/environments/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets environment list
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironmentList: async (
      offset?: number,
      limit?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/environments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EnvironmentsApi - functional programming interface
 * @export
 */
export const EnvironmentsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EnvironmentsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create an environment
     * @param {string} name Name of environment
     * @param {EnvironmentConfig} [environmentConfig] Information about creating an environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEnvironment(
      name: string,
      environmentConfig?: EnvironmentConfig,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironment(
        name,
        environmentConfig,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete an environment
     * @param {string} name Name of environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteEnvironment(
      name: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironment(name, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets environment
     * @param {string} name Name of environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnvironment(
      name: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentRuntimeInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironment(name, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets environment list
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnvironmentList(
      offset?: number,
      limit?: number,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentRuntimeInfos>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentList(
        offset,
        limit,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * EnvironmentsApi - factory interface
 * @export
 */
export const EnvironmentsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = EnvironmentsApiFp(configuration);
  return {
    /**
     *
     * @summary Create an environment
     * @param {string} name Name of environment
     * @param {EnvironmentConfig} [environmentConfig] Information about creating an environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEnvironment(
      name: string,
      environmentConfig?: EnvironmentConfig,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .createEnvironment(name, environmentConfig, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete an environment
     * @param {string} name Name of environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEnvironment(name: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteEnvironment(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets environment
     * @param {string} name Name of environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironment(name: string, options?: any): AxiosPromise<EnvironmentRuntimeInfo> {
      return localVarFp.getEnvironment(name, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets environment list
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironmentList(
      offset?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<EnvironmentRuntimeInfos> {
      return localVarFp
        .getEnvironmentList(offset, limit, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * EnvironmentsApi - object-oriented interface
 * @export
 * @class EnvironmentsApi
 * @extends {BaseAPI}
 */
export class EnvironmentsApi extends BaseAPI {
  /**
   *
   * @summary Create an environment
   * @param {string} name Name of environment
   * @param {EnvironmentConfig} [environmentConfig] Information about creating an environment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  public createEnvironment(name: string, environmentConfig?: EnvironmentConfig, options?: any) {
    return EnvironmentsApiFp(this.configuration)
      .createEnvironment(name, environmentConfig, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete an environment
   * @param {string} name Name of environment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  public deleteEnvironment(name: string, options?: any) {
    return EnvironmentsApiFp(this.configuration)
      .deleteEnvironment(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets environment
   * @param {string} name Name of environment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  public getEnvironment(name: string, options?: any) {
    return EnvironmentsApiFp(this.configuration)
      .getEnvironment(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets environment list
   * @param {number} [offset] The number of items to skip before starting to collect the result set
   * @param {number} [limit] The numbers of items to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  public getEnvironmentList(offset?: number, limit?: number, options?: any) {
    return EnvironmentsApiFp(this.configuration)
      .getEnvironmentList(offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FinishedApi - axios parameter creator
 * @export
 */
export const FinishedApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary check joined competition
     * @param {string} competitionID computition id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    competitionCompetitionIDGet: async (
      competitionID: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'competitionID' is not null or undefined
      assertParamExists('competitionCompetitionIDGet', 'competitionID', competitionID);
      const localVarPath = `/competition/{competitionID}`.replace(
        `{${'competitionID'}}`,
        encodeURIComponent(String(competitionID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get invitation number in a competition
     * @param {string} competitionID computition id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    competitionCompetitionIDInvitationGet: async (
      competitionID: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'competitionID' is not null or undefined
      assertParamExists('competitionCompetitionIDInvitationGet', 'competitionID', competitionID);
      const localVarPath = `/competition/{competitionID}/invitation`.replace(
        `{${'competitionID'}}`,
        encodeURIComponent(String(competitionID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary join competition
     * @param {string} competitionID computition id
     * @param {string} [inviter] inviter id
     * @param {{ [key: string]: string; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    competitionCompetitionIDPost: async (
      competitionID: string,
      inviter?: string,
      requestBody?: { [key: string]: string },
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'competitionID' is not null or undefined
      assertParamExists('competitionCompetitionIDPost', 'competitionID', competitionID);
      const localVarPath = `/competition/{competitionID}`.replace(
        `{${'competitionID'}}`,
        encodeURIComponent(String(competitionID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (inviter !== undefined) {
        localVarQueryParameter['inviter'] = inviter;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary list competition
     * @param {string} [beginning]
     * @param {string} [end]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    competitionGet: async (
      beginning?: string,
      end?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/competition`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (beginning !== undefined) {
        localVarQueryParameter['beginning'] =
          (beginning as any) instanceof Date ? (beginning as any).toISOString() : beginning;
      }

      if (end !== undefined) {
        localVarQueryParameter['end'] =
          (end as any) instanceof Date ? (end as any).toISOString() : end;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create an app
     * @param {string} name application name
     * @param {ApplicationConfig} [applicationConfig]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApplication: async (
      name: string,
      applicationConfig?: ApplicationConfig,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('createApplication', 'name', name);
      const localVarPath = `/applications/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        applicationConfig,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create directory
     * @param {string} path File or Directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDirectory: async (path: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('createDirectory', 'path', path);
      const localVarPath = `/storage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (path !== undefined) {
        localVarQueryParameter['path'] = path;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create an environment
     * @param {string} name Name of environment
     * @param {EnvironmentConfig} [environmentConfig] Information about creating an environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEnvironment: async (
      name: string,
      environmentConfig?: EnvironmentConfig,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('createEnvironment', 'name', name);
      const localVarPath = `/environments/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        environmentConfig,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete an application instance
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApplication: async (name: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deleteApplication', 'name', name);
      const localVarPath = `/applications/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete directory or file
     * @param {string} path Directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDirectoryOrFile: async (path: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('deleteDirectoryOrFile', 'path', path);
      const localVarPath = `/storage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (path !== undefined) {
        localVarQueryParameter['path'] = path;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete an environment
     * @param {string} name Name of environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEnvironment: async (name: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deleteEnvironment', 'name', name);
      const localVarPath = `/environments/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get application list
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationList: async (
      offset?: number,
      limit?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/applications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a application metadata
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationMetadata: async (name: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getApplicationMetadata', 'name', name);
      const localVarPath = `/applications/{name}/metadata`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets application notes
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationNotes: async (name: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getApplicationNotes', 'name', name);
      const localVarPath = `/applications/{name}/notes`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a application pods
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationPods: async (name: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getApplicationPods', 'name', name);
      const localVarPath = `/applications/{name}/pods`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a application services
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationServices: async (name: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getApplicationServices', 'name', name);
      const localVarPath = `/applications/{name}/services`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a chart
     * @param {ChartCategory} category chart repo
     * @param {string} name chart name
     * @param {string} version chart version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppstoreChart: async (
      category: ChartCategory,
      name: string,
      version: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'category' is not null or undefined
      assertParamExists('getAppstoreChart', 'category', category);
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getAppstoreChart', 'name', name);
      // verify required parameter 'version' is not null or undefined
      assertParamExists('getAppstoreChart', 'version', version);
      const localVarPath = `/appstore/charts/{category}/{name}/{version}`
        .replace(`{${'category'}}`, encodeURIComponent(String(category)))
        .replace(`{${'name'}}`, encodeURIComponent(String(name)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get chart list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppstoreChartList: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/appstore/charts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get computing unit specifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getComputingUnitSpecs: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/computing_resource/specs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get container log
     * @param {string} podName pod name in kubernetes
     * @param {string} [containerName] container name in kubernetes
     * @param {number} [tailLines] tail lines of the log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContainerLog: async (
      podName: string,
      containerName?: string,
      tailLines?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'podName' is not null or undefined
      assertParamExists('getContainerLog', 'podName', podName);
      const localVarPath = `/log/pod/{pod_name}`.replace(
        `{${'pod_name'}}`,
        encodeURIComponent(String(podName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (containerName !== undefined) {
        localVarQueryParameter['container_name'] = containerName;
      }

      if (tailLines !== undefined) {
        localVarQueryParameter['tail_lines'] = tailLines;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get directory
     * @param {string} [path] Directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDirectory: async (path?: string, options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/storage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (path !== undefined) {
        localVarQueryParameter['path'] = path;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets environment
     * @param {string} name Name of environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironment: async (name: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getEnvironment', 'name', name);
      const localVarPath = `/environments/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets environment list
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironmentList: async (
      offset?: number,
      limit?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/environments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/user/info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete image
     * @param {string} repo
     * @param {string} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesDelete: async (repo: string, tag: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'repo' is not null or undefined
      assertParamExists('imagesDelete', 'repo', repo);
      // verify required parameter 'tag' is not null or undefined
      assertParamExists('imagesDelete', 'tag', tag);
      const localVarPath = `/images`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (repo !== undefined) {
        localVarQueryParameter['repo'] = repo;
      }

      if (tag !== undefined) {
        localVarQueryParameter['tag'] = tag;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get images
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesGet: async (
      page?: number,
      pageSize?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/images`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove importing from list
     * @param {number} importingId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesImportingDelete: async (importingId: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'importingId' is not null or undefined
      assertParamExists('imagesImportingDelete', 'importingId', importingId);
      const localVarPath = `/images/importing`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (importingId !== undefined) {
        localVarQueryParameter['importing_id'] = importingId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Import images
     * @param {number} registryId image registry id
     * @param {string} repo
     * @param {string} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesImportingPost: async (
      registryId: number,
      repo: string,
      tag: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'registryId' is not null or undefined
      assertParamExists('imagesImportingPost', 'registryId', registryId);
      // verify required parameter 'repo' is not null or undefined
      assertParamExists('imagesImportingPost', 'repo', repo);
      // verify required parameter 'tag' is not null or undefined
      assertParamExists('imagesImportingPost', 'tag', tag);
      const localVarPath = `/images/importing`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (registryId !== undefined) {
        localVarQueryParameter['registryId'] = registryId;
      }

      if (repo !== undefined) {
        localVarQueryParameter['repo'] = repo;
      }

      if (tag !== undefined) {
        localVarQueryParameter['tag'] = tag;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Stop importing
     * @param {number} importingId importing id to stop
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesImportingPut: async (importingId: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'importingId' is not null or undefined
      assertParamExists('imagesImportingPut', 'importingId', importingId);
      const localVarPath = `/images/importing`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (importingId !== undefined) {
        localVarQueryParameter['importing_id'] = importingId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user project info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesInfoGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/images/info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Copy image
     * @param {string} srcRepo
     * @param {string} destRepo
     * @param {string} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesPut: async (
      srcRepo: string,
      destRepo: string,
      tag: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'srcRepo' is not null or undefined
      assertParamExists('imagesPut', 'srcRepo', srcRepo);
      // verify required parameter 'destRepo' is not null or undefined
      assertParamExists('imagesPut', 'destRepo', destRepo);
      // verify required parameter 'tag' is not null or undefined
      assertParamExists('imagesPut', 'tag', tag);
      const localVarPath = `/images`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (srcRepo !== undefined) {
        localVarQueryParameter['src_repo'] = srcRepo;
      }

      if (destRepo !== undefined) {
        localVarQueryParameter['dest_repo'] = destRepo;
      }

      if (tag !== undefined) {
        localVarQueryParameter['tag'] = tag;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get registry list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesRegistryGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/images/registry`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List importing images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listImportingImages: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/images/importing`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary image version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pineappleVersion: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/version`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get public images
     * @param {string} [filter]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publicImagesGet: async (
      filter?: string,
      page?: number,
      pageSize?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/public_images`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get public project info
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publicImagesInfoGet: async (filter?: string, options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/public_images/info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Download File
     * @param {string} path Source path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storageDownloadGet: async (path: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('storageDownloadGet', 'path', path);
      const localVarPath = `/storage/download`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (path !== undefined) {
        localVarQueryParameter['path'] = path;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Upload File
     * @param {string} [path] Destination directory
     * @param {any} [file] file type for upload and Download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storageUploadPost: async (
      path?: string,
      file?: any,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/storage/upload`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (path !== undefined) {
        localVarQueryParameter['path'] = path;
      }

      if (file !== undefined) {
        localVarFormParams.append('file', file as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Upload chart
     * @param {ChartCategory} category chart repo
     * @param {any} [file] file type for upload and Download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadChart: async (
      category: ChartCategory,
      file?: any,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'category' is not null or undefined
      assertParamExists('uploadChart', 'category', category);
      const localVarPath = `/appstore/charts/{category}`.replace(
        `{${'category'}}`,
        encodeURIComponent(String(category)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (file !== undefined) {
        localVarFormParams.append('file', file as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary init user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userInitPost: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/user/init`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get user task info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userTasksGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/user/tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FinishedApi - functional programming interface
 * @export
 */
export const FinishedApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FinishedApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary check joined competition
     * @param {string} competitionID computition id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async competitionCompetitionIDGet(
      competitionID: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.competitionCompetitionIDGet(
        competitionID,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get invitation number in a competition
     * @param {string} competitionID computition id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async competitionCompetitionIDInvitationGet(
      competitionID: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.competitionCompetitionIDInvitationGet(
        competitionID,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary join competition
     * @param {string} competitionID computition id
     * @param {string} [inviter] inviter id
     * @param {{ [key: string]: string; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async competitionCompetitionIDPost(
      competitionID: string,
      inviter?: string,
      requestBody?: { [key: string]: string },
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.competitionCompetitionIDPost(
        competitionID,
        inviter,
        requestBody,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary list competition
     * @param {string} [beginning]
     * @param {string} [end]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async competitionGet(
      beginning?: string,
      end?: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CompetitionInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.competitionGet(
        beginning,
        end,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Create an app
     * @param {string} name application name
     * @param {ApplicationConfig} [applicationConfig]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createApplication(
      name: string,
      applicationConfig?: ApplicationConfig,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(
        name,
        applicationConfig,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Create directory
     * @param {string} path File or Directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDirectory(
      path: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDirectory(path, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Create an environment
     * @param {string} name Name of environment
     * @param {EnvironmentConfig} [environmentConfig] Information about creating an environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEnvironment(
      name: string,
      environmentConfig?: EnvironmentConfig,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironment(
        name,
        environmentConfig,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete an application instance
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteApplication(
      name: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(name, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete directory or file
     * @param {string} path Directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteDirectoryOrFile(
      path: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDirectoryOrFile(
        path,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete an environment
     * @param {string} name Name of environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteEnvironment(
      name: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironment(name, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get application list
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApplicationList(
      offset?: number,
      limit?: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationList(
        offset,
        limit,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a application metadata
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApplicationMetadata(
      name: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationInstanceMetadata>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationMetadata(
        name,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets application notes
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApplicationNotes(
      name: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationNotes(name, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a application pods
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApplicationPods(
      name: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationInstancePodList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationPods(name, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a application services
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApplicationServices(
      name: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationInstanceServiceList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationServices(
        name,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get a chart
     * @param {ChartCategory} category chart repo
     * @param {string} name chart name
     * @param {string} version chart version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAppstoreChart(
      category: ChartCategory,
      name: string,
      version: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chart>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAppstoreChart(
        category,
        name,
        version,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get chart list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAppstoreChartList(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartMetaDataList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAppstoreChartList(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get computing unit specifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getComputingUnitSpecs(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ComputeUnitSpec>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getComputingUnitSpecs(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get container log
     * @param {string} podName pod name in kubernetes
     * @param {string} [containerName] container name in kubernetes
     * @param {number} [tailLines] tail lines of the log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContainerLog(
      podName: string,
      containerName?: string,
      tailLines?: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerLog(
        podName,
        containerName,
        tailLines,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get directory
     * @param {string} [path] Directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDirectory(
      path?: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDirectory(path, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets environment
     * @param {string} name Name of environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnvironment(
      name: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentRuntimeInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironment(name, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets environment list
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnvironmentList(
      offset?: number,
      limit?: number,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentRuntimeInfos>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentList(
        offset,
        limit,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete image
     * @param {string} repo
     * @param {string} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesDelete(
      repo: string,
      tag: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.imagesDelete(repo, tag, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get images
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesGet(
      page?: number,
      pageSize?: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.imagesGet(page, pageSize, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Remove importing from list
     * @param {number} importingId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesImportingDelete(
      importingId: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.imagesImportingDelete(
        importingId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Import images
     * @param {number} registryId image registry id
     * @param {string} repo
     * @param {string} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesImportingPost(
      registryId: number,
      repo: string,
      tag: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.imagesImportingPost(
        registryId,
        repo,
        tag,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Stop importing
     * @param {number} importingId importing id to stop
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesImportingPut(
      importingId: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.imagesImportingPut(
        importingId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get user project info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesInfoGet(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectUserInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.imagesInfoGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Copy image
     * @param {string} srcRepo
     * @param {string} destRepo
     * @param {string} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesPut(
      srcRepo: string,
      destRepo: string,
      tag: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.imagesPut(
        srcRepo,
        destRepo,
        tag,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get registry list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesRegistryGet(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageRegistryInfo>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.imagesRegistryGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary List importing images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listImportingImages(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageImportingInfo>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listImportingImages(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary image version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pineappleVersion(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pineappleVersion(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get public images
     * @param {string} [filter]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publicImagesGet(
      filter?: string,
      page?: number,
      pageSize?: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.publicImagesGet(
        filter,
        page,
        pageSize,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get public project info
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publicImagesInfoGet(
      filter?: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectUserInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.publicImagesInfoGet(
        filter,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Download File
     * @param {string} path Source path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storageDownloadGet(
      path: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storageDownloadGet(path, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Upload File
     * @param {string} [path] Destination directory
     * @param {any} [file] file type for upload and Download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storageUploadPost(
      path?: string,
      file?: any,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storageUploadPost(
        path,
        file,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Upload chart
     * @param {ChartCategory} category chart repo
     * @param {any} [file] file type for upload and Download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadChart(
      category: ChartCategory,
      file?: any,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadChart(
        category,
        file,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary init user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userInitPost(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userInitPost(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get user task info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userTasksGet(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTasksInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userTasksGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * FinishedApi - factory interface
 * @export
 */
export const FinishedApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FinishedApiFp(configuration);
  return {
    /**
     *
     * @summary check joined competition
     * @param {string} competitionID computition id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    competitionCompetitionIDGet(competitionID: string, options?: any): AxiosPromise<boolean> {
      return localVarFp
        .competitionCompetitionIDGet(competitionID, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary get invitation number in a competition
     * @param {string} competitionID computition id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    competitionCompetitionIDInvitationGet(
      competitionID: string,
      options?: any,
    ): AxiosPromise<number> {
      return localVarFp
        .competitionCompetitionIDInvitationGet(competitionID, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary join competition
     * @param {string} competitionID computition id
     * @param {string} [inviter] inviter id
     * @param {{ [key: string]: string; }} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    competitionCompetitionIDPost(
      competitionID: string,
      inviter?: string,
      requestBody?: { [key: string]: string },
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .competitionCompetitionIDPost(competitionID, inviter, requestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary list competition
     * @param {string} [beginning]
     * @param {string} [end]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    competitionGet(
      beginning?: string,
      end?: string,
      options?: any,
    ): AxiosPromise<Array<CompetitionInfo>> {
      return localVarFp
        .competitionGet(beginning, end, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create an app
     * @param {string} name application name
     * @param {ApplicationConfig} [applicationConfig]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApplication(
      name: string,
      applicationConfig?: ApplicationConfig,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .createApplication(name, applicationConfig, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create directory
     * @param {string} path File or Directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDirectory(path: string, options?: any): AxiosPromise<void> {
      return localVarFp.createDirectory(path, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create an environment
     * @param {string} name Name of environment
     * @param {EnvironmentConfig} [environmentConfig] Information about creating an environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEnvironment(
      name: string,
      environmentConfig?: EnvironmentConfig,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .createEnvironment(name, environmentConfig, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete an application instance
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApplication(name: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteApplication(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete directory or file
     * @param {string} path Directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDirectoryOrFile(path: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteDirectoryOrFile(path, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete an environment
     * @param {string} name Name of environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEnvironment(name: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteEnvironment(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get application list
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationList(
      offset?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<ApplicationList> {
      return localVarFp
        .getApplicationList(offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a application metadata
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationMetadata(name: string, options?: any): AxiosPromise<ApplicationInstanceMetadata> {
      return localVarFp
        .getApplicationMetadata(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets application notes
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationNotes(name: string, options?: any): AxiosPromise<InlineResponse200> {
      return localVarFp
        .getApplicationNotes(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a application pods
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationPods(name: string, options?: any): AxiosPromise<ApplicationInstancePodList> {
      return localVarFp
        .getApplicationPods(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a application services
     * @param {string} name application name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationServices(
      name: string,
      options?: any,
    ): AxiosPromise<ApplicationInstanceServiceList> {
      return localVarFp
        .getApplicationServices(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a chart
     * @param {ChartCategory} category chart repo
     * @param {string} name chart name
     * @param {string} version chart version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppstoreChart(
      category: ChartCategory,
      name: string,
      version: string,
      options?: any,
    ): AxiosPromise<Chart> {
      return localVarFp
        .getAppstoreChart(category, name, version, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get chart list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppstoreChartList(options?: any): AxiosPromise<ChartMetaDataList> {
      return localVarFp.getAppstoreChartList(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get computing unit specifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getComputingUnitSpecs(options?: any): AxiosPromise<Array<ComputeUnitSpec>> {
      return localVarFp.getComputingUnitSpecs(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary get container log
     * @param {string} podName pod name in kubernetes
     * @param {string} [containerName] container name in kubernetes
     * @param {number} [tailLines] tail lines of the log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContainerLog(
      podName: string,
      containerName?: string,
      tailLines?: number,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .getContainerLog(podName, containerName, tailLines, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get directory
     * @param {string} [path] Directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDirectory(path?: string, options?: any): AxiosPromise<Array<FileInfo>> {
      return localVarFp.getDirectory(path, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets environment
     * @param {string} name Name of environment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironment(name: string, options?: any): AxiosPromise<EnvironmentRuntimeInfo> {
      return localVarFp.getEnvironment(name, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets environment list
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironmentList(
      offset?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<EnvironmentRuntimeInfos> {
      return localVarFp
        .getEnvironmentList(offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(options?: any): AxiosPromise<UserInfo> {
      return localVarFp.getUser(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete image
     * @param {string} repo
     * @param {string} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesDelete(repo: string, tag: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .imagesDelete(repo, tag, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get images
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesGet(page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ImageInfo>> {
      return localVarFp
        .imagesGet(page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove importing from list
     * @param {number} importingId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesImportingDelete(importingId: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .imagesImportingDelete(importingId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Import images
     * @param {number} registryId image registry id
     * @param {string} repo
     * @param {string} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesImportingPost(
      registryId: number,
      repo: string,
      tag: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .imagesImportingPost(registryId, repo, tag, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Stop importing
     * @param {number} importingId importing id to stop
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesImportingPut(importingId: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .imagesImportingPut(importingId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get user project info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesInfoGet(options?: any): AxiosPromise<ProjectUserInfo> {
      return localVarFp.imagesInfoGet(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Copy image
     * @param {string} srcRepo
     * @param {string} destRepo
     * @param {string} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesPut(srcRepo: string, destRepo: string, tag: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .imagesPut(srcRepo, destRepo, tag, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get registry list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesRegistryGet(options?: any): AxiosPromise<Array<ImageRegistryInfo>> {
      return localVarFp.imagesRegistryGet(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List importing images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listImportingImages(options?: any): AxiosPromise<Array<ImageImportingInfo>> {
      return localVarFp.listImportingImages(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary image version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pineappleVersion(options?: any): AxiosPromise<string> {
      return localVarFp.pineappleVersion(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get public images
     * @param {string} [filter]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publicImagesGet(
      filter?: string,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<Array<ImageInfo>> {
      return localVarFp
        .publicImagesGet(filter, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get public project info
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publicImagesInfoGet(filter?: string, options?: any): AxiosPromise<ProjectUserInfo> {
      return localVarFp
        .publicImagesInfoGet(filter, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Download File
     * @param {string} path Source path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storageDownloadGet(path: string, options?: any): AxiosPromise<any> {
      return localVarFp
        .storageDownloadGet(path, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Upload File
     * @param {string} [path] Destination directory
     * @param {any} [file] file type for upload and Download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storageUploadPost(path?: string, file?: any, options?: any): AxiosPromise<void> {
      return localVarFp
        .storageUploadPost(path, file, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Upload chart
     * @param {ChartCategory} category chart repo
     * @param {any} [file] file type for upload and Download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadChart(category: ChartCategory, file?: any, options?: any): AxiosPromise<void> {
      return localVarFp
        .uploadChart(category, file, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary init user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userInitPost(options?: any): AxiosPromise<void> {
      return localVarFp.userInitPost(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary get user task info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userTasksGet(options?: any): AxiosPromise<UserTasksInfo> {
      return localVarFp.userTasksGet(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * FinishedApi - object-oriented interface
 * @export
 * @class FinishedApi
 * @extends {BaseAPI}
 */
export class FinishedApi extends BaseAPI {
  /**
   *
   * @summary check joined competition
   * @param {string} competitionID computition id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public competitionCompetitionIDGet(competitionID: string, options?: any) {
    return FinishedApiFp(this.configuration)
      .competitionCompetitionIDGet(competitionID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get invitation number in a competition
   * @param {string} competitionID computition id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public competitionCompetitionIDInvitationGet(competitionID: string, options?: any) {
    return FinishedApiFp(this.configuration)
      .competitionCompetitionIDInvitationGet(competitionID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary join competition
   * @param {string} competitionID computition id
   * @param {string} [inviter] inviter id
   * @param {{ [key: string]: string; }} [requestBody]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public competitionCompetitionIDPost(
    competitionID: string,
    inviter?: string,
    requestBody?: { [key: string]: string },
    options?: any,
  ) {
    return FinishedApiFp(this.configuration)
      .competitionCompetitionIDPost(competitionID, inviter, requestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary list competition
   * @param {string} [beginning]
   * @param {string} [end]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public competitionGet(beginning?: string, end?: string, options?: any) {
    return FinishedApiFp(this.configuration)
      .competitionGet(beginning, end, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create an app
   * @param {string} name application name
   * @param {ApplicationConfig} [applicationConfig]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public createApplication(name: string, applicationConfig?: ApplicationConfig, options?: any) {
    return FinishedApiFp(this.configuration)
      .createApplication(name, applicationConfig, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create directory
   * @param {string} path File or Directory path
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public createDirectory(path: string, options?: any) {
    return FinishedApiFp(this.configuration)
      .createDirectory(path, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create an environment
   * @param {string} name Name of environment
   * @param {EnvironmentConfig} [environmentConfig] Information about creating an environment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public createEnvironment(name: string, environmentConfig?: EnvironmentConfig, options?: any) {
    return FinishedApiFp(this.configuration)
      .createEnvironment(name, environmentConfig, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete an application instance
   * @param {string} name application name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public deleteApplication(name: string, options?: any) {
    return FinishedApiFp(this.configuration)
      .deleteApplication(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete directory or file
   * @param {string} path Directory path
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public deleteDirectoryOrFile(path: string, options?: any) {
    return FinishedApiFp(this.configuration)
      .deleteDirectoryOrFile(path, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete an environment
   * @param {string} name Name of environment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public deleteEnvironment(name: string, options?: any) {
    return FinishedApiFp(this.configuration)
      .deleteEnvironment(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get application list
   * @param {number} [offset] The number of items to skip before starting to collect the result set
   * @param {number} [limit] The numbers of items to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public getApplicationList(offset?: number, limit?: number, options?: any) {
    return FinishedApiFp(this.configuration)
      .getApplicationList(offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a application metadata
   * @param {string} name application name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public getApplicationMetadata(name: string, options?: any) {
    return FinishedApiFp(this.configuration)
      .getApplicationMetadata(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets application notes
   * @param {string} name application name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public getApplicationNotes(name: string, options?: any) {
    return FinishedApiFp(this.configuration)
      .getApplicationNotes(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a application pods
   * @param {string} name application name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public getApplicationPods(name: string, options?: any) {
    return FinishedApiFp(this.configuration)
      .getApplicationPods(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a application services
   * @param {string} name application name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public getApplicationServices(name: string, options?: any) {
    return FinishedApiFp(this.configuration)
      .getApplicationServices(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a chart
   * @param {ChartCategory} category chart repo
   * @param {string} name chart name
   * @param {string} version chart version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public getAppstoreChart(category: ChartCategory, name: string, version: string, options?: any) {
    return FinishedApiFp(this.configuration)
      .getAppstoreChart(category, name, version, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get chart list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public getAppstoreChartList(options?: any) {
    return FinishedApiFp(this.configuration)
      .getAppstoreChartList(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get computing unit specifications
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public getComputingUnitSpecs(options?: any) {
    return FinishedApiFp(this.configuration)
      .getComputingUnitSpecs(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get container log
   * @param {string} podName pod name in kubernetes
   * @param {string} [containerName] container name in kubernetes
   * @param {number} [tailLines] tail lines of the log
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public getContainerLog(
    podName: string,
    containerName?: string,
    tailLines?: number,
    options?: any,
  ) {
    return FinishedApiFp(this.configuration)
      .getContainerLog(podName, containerName, tailLines, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get directory
   * @param {string} [path] Directory path
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public getDirectory(path?: string, options?: any) {
    return FinishedApiFp(this.configuration)
      .getDirectory(path, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets environment
   * @param {string} name Name of environment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public getEnvironment(name: string, options?: any) {
    return FinishedApiFp(this.configuration)
      .getEnvironment(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets environment list
   * @param {number} [offset] The number of items to skip before starting to collect the result set
   * @param {number} [limit] The numbers of items to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public getEnvironmentList(offset?: number, limit?: number, options?: any) {
    return FinishedApiFp(this.configuration)
      .getEnvironmentList(offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public getUser(options?: any) {
    return FinishedApiFp(this.configuration)
      .getUser(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete image
   * @param {string} repo
   * @param {string} tag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public imagesDelete(repo: string, tag: string, options?: any) {
    return FinishedApiFp(this.configuration)
      .imagesDelete(repo, tag, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get images
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public imagesGet(page?: number, pageSize?: number, options?: any) {
    return FinishedApiFp(this.configuration)
      .imagesGet(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove importing from list
   * @param {number} importingId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public imagesImportingDelete(importingId: number, options?: any) {
    return FinishedApiFp(this.configuration)
      .imagesImportingDelete(importingId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Import images
   * @param {number} registryId image registry id
   * @param {string} repo
   * @param {string} tag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public imagesImportingPost(registryId: number, repo: string, tag: string, options?: any) {
    return FinishedApiFp(this.configuration)
      .imagesImportingPost(registryId, repo, tag, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Stop importing
   * @param {number} importingId importing id to stop
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public imagesImportingPut(importingId: number, options?: any) {
    return FinishedApiFp(this.configuration)
      .imagesImportingPut(importingId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user project info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public imagesInfoGet(options?: any) {
    return FinishedApiFp(this.configuration)
      .imagesInfoGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Copy image
   * @param {string} srcRepo
   * @param {string} destRepo
   * @param {string} tag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public imagesPut(srcRepo: string, destRepo: string, tag: string, options?: any) {
    return FinishedApiFp(this.configuration)
      .imagesPut(srcRepo, destRepo, tag, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get registry list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public imagesRegistryGet(options?: any) {
    return FinishedApiFp(this.configuration)
      .imagesRegistryGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List importing images
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public listImportingImages(options?: any) {
    return FinishedApiFp(this.configuration)
      .listImportingImages(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary image version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public pineappleVersion(options?: any) {
    return FinishedApiFp(this.configuration)
      .pineappleVersion(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get public images
   * @param {string} [filter]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public publicImagesGet(filter?: string, page?: number, pageSize?: number, options?: any) {
    return FinishedApiFp(this.configuration)
      .publicImagesGet(filter, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get public project info
   * @param {string} [filter]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public publicImagesInfoGet(filter?: string, options?: any) {
    return FinishedApiFp(this.configuration)
      .publicImagesInfoGet(filter, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Download File
   * @param {string} path Source path
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public storageDownloadGet(path: string, options?: any) {
    return FinishedApiFp(this.configuration)
      .storageDownloadGet(path, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Upload File
   * @param {string} [path] Destination directory
   * @param {any} [file] file type for upload and Download
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public storageUploadPost(path?: string, file?: any, options?: any) {
    return FinishedApiFp(this.configuration)
      .storageUploadPost(path, file, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Upload chart
   * @param {ChartCategory} category chart repo
   * @param {any} [file] file type for upload and Download
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public uploadChart(category: ChartCategory, file?: any, options?: any) {
    return FinishedApiFp(this.configuration)
      .uploadChart(category, file, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary init user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public userInitPost(options?: any) {
    return FinishedApiFp(this.configuration)
      .userInitPost(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get user task info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FinishedApi
   */
  public userTasksGet(options?: any) {
    return FinishedApiFp(this.configuration)
      .userTasksGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete image
     * @param {string} repo
     * @param {string} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesDelete: async (repo: string, tag: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'repo' is not null or undefined
      assertParamExists('imagesDelete', 'repo', repo);
      // verify required parameter 'tag' is not null or undefined
      assertParamExists('imagesDelete', 'tag', tag);
      const localVarPath = `/images`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (repo !== undefined) {
        localVarQueryParameter['repo'] = repo;
      }

      if (tag !== undefined) {
        localVarQueryParameter['tag'] = tag;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get images
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesGet: async (
      page?: number,
      pageSize?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/images`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove importing from list
     * @param {number} importingId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesImportingDelete: async (importingId: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'importingId' is not null or undefined
      assertParamExists('imagesImportingDelete', 'importingId', importingId);
      const localVarPath = `/images/importing`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (importingId !== undefined) {
        localVarQueryParameter['importing_id'] = importingId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Import images
     * @param {number} registryId image registry id
     * @param {string} repo
     * @param {string} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesImportingPost: async (
      registryId: number,
      repo: string,
      tag: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'registryId' is not null or undefined
      assertParamExists('imagesImportingPost', 'registryId', registryId);
      // verify required parameter 'repo' is not null or undefined
      assertParamExists('imagesImportingPost', 'repo', repo);
      // verify required parameter 'tag' is not null or undefined
      assertParamExists('imagesImportingPost', 'tag', tag);
      const localVarPath = `/images/importing`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (registryId !== undefined) {
        localVarQueryParameter['registryId'] = registryId;
      }

      if (repo !== undefined) {
        localVarQueryParameter['repo'] = repo;
      }

      if (tag !== undefined) {
        localVarQueryParameter['tag'] = tag;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Stop importing
     * @param {number} importingId importing id to stop
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesImportingPut: async (importingId: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'importingId' is not null or undefined
      assertParamExists('imagesImportingPut', 'importingId', importingId);
      const localVarPath = `/images/importing`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (importingId !== undefined) {
        localVarQueryParameter['importing_id'] = importingId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user project info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesInfoGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/images/info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Copy image
     * @param {string} srcRepo
     * @param {string} destRepo
     * @param {string} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesPut: async (
      srcRepo: string,
      destRepo: string,
      tag: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'srcRepo' is not null or undefined
      assertParamExists('imagesPut', 'srcRepo', srcRepo);
      // verify required parameter 'destRepo' is not null or undefined
      assertParamExists('imagesPut', 'destRepo', destRepo);
      // verify required parameter 'tag' is not null or undefined
      assertParamExists('imagesPut', 'tag', tag);
      const localVarPath = `/images`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (srcRepo !== undefined) {
        localVarQueryParameter['src_repo'] = srcRepo;
      }

      if (destRepo !== undefined) {
        localVarQueryParameter['dest_repo'] = destRepo;
      }

      if (tag !== undefined) {
        localVarQueryParameter['tag'] = tag;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get registry list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesRegistryGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/images/registry`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List importing images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listImportingImages: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/images/importing`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get public images
     * @param {string} [filter]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publicImagesGet: async (
      filter?: string,
      page?: number,
      pageSize?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/public_images`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['page_size'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get public project info
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publicImagesInfoGet: async (filter?: string, options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/public_images/info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Delete image
     * @param {string} repo
     * @param {string} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesDelete(
      repo: string,
      tag: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.imagesDelete(repo, tag, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get images
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesGet(
      page?: number,
      pageSize?: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.imagesGet(page, pageSize, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Remove importing from list
     * @param {number} importingId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesImportingDelete(
      importingId: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.imagesImportingDelete(
        importingId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Import images
     * @param {number} registryId image registry id
     * @param {string} repo
     * @param {string} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesImportingPost(
      registryId: number,
      repo: string,
      tag: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.imagesImportingPost(
        registryId,
        repo,
        tag,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Stop importing
     * @param {number} importingId importing id to stop
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesImportingPut(
      importingId: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.imagesImportingPut(
        importingId,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get user project info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesInfoGet(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectUserInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.imagesInfoGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Copy image
     * @param {string} srcRepo
     * @param {string} destRepo
     * @param {string} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesPut(
      srcRepo: string,
      destRepo: string,
      tag: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.imagesPut(
        srcRepo,
        destRepo,
        tag,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get registry list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imagesRegistryGet(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageRegistryInfo>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.imagesRegistryGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary List importing images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listImportingImages(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageImportingInfo>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listImportingImages(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get public images
     * @param {string} [filter]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publicImagesGet(
      filter?: string,
      page?: number,
      pageSize?: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.publicImagesGet(
        filter,
        page,
        pageSize,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get public project info
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publicImagesInfoGet(
      filter?: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectUserInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.publicImagesInfoGet(
        filter,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ImagesApiFp(configuration);
  return {
    /**
     *
     * @summary Delete image
     * @param {string} repo
     * @param {string} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesDelete(repo: string, tag: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .imagesDelete(repo, tag, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get images
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesGet(page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ImageInfo>> {
      return localVarFp
        .imagesGet(page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove importing from list
     * @param {number} importingId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesImportingDelete(importingId: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .imagesImportingDelete(importingId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Import images
     * @param {number} registryId image registry id
     * @param {string} repo
     * @param {string} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesImportingPost(
      registryId: number,
      repo: string,
      tag: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .imagesImportingPost(registryId, repo, tag, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Stop importing
     * @param {number} importingId importing id to stop
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesImportingPut(importingId: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .imagesImportingPut(importingId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get user project info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesInfoGet(options?: any): AxiosPromise<ProjectUserInfo> {
      return localVarFp.imagesInfoGet(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Copy image
     * @param {string} srcRepo
     * @param {string} destRepo
     * @param {string} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesPut(srcRepo: string, destRepo: string, tag: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .imagesPut(srcRepo, destRepo, tag, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get registry list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imagesRegistryGet(options?: any): AxiosPromise<Array<ImageRegistryInfo>> {
      return localVarFp.imagesRegistryGet(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List importing images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listImportingImages(options?: any): AxiosPromise<Array<ImageImportingInfo>> {
      return localVarFp.listImportingImages(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get public images
     * @param {string} [filter]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publicImagesGet(
      filter?: string,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<Array<ImageInfo>> {
      return localVarFp
        .publicImagesGet(filter, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get public project info
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publicImagesInfoGet(filter?: string, options?: any): AxiosPromise<ProjectUserInfo> {
      return localVarFp
        .publicImagesInfoGet(filter, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
  /**
   *
   * @summary Delete image
   * @param {string} repo
   * @param {string} tag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public imagesDelete(repo: string, tag: string, options?: any) {
    return ImagesApiFp(this.configuration)
      .imagesDelete(repo, tag, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get images
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public imagesGet(page?: number, pageSize?: number, options?: any) {
    return ImagesApiFp(this.configuration)
      .imagesGet(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove importing from list
   * @param {number} importingId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public imagesImportingDelete(importingId: number, options?: any) {
    return ImagesApiFp(this.configuration)
      .imagesImportingDelete(importingId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Import images
   * @param {number} registryId image registry id
   * @param {string} repo
   * @param {string} tag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public imagesImportingPost(registryId: number, repo: string, tag: string, options?: any) {
    return ImagesApiFp(this.configuration)
      .imagesImportingPost(registryId, repo, tag, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Stop importing
   * @param {number} importingId importing id to stop
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public imagesImportingPut(importingId: number, options?: any) {
    return ImagesApiFp(this.configuration)
      .imagesImportingPut(importingId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user project info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public imagesInfoGet(options?: any) {
    return ImagesApiFp(this.configuration)
      .imagesInfoGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Copy image
   * @param {string} srcRepo
   * @param {string} destRepo
   * @param {string} tag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public imagesPut(srcRepo: string, destRepo: string, tag: string, options?: any) {
    return ImagesApiFp(this.configuration)
      .imagesPut(srcRepo, destRepo, tag, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get registry list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public imagesRegistryGet(options?: any) {
    return ImagesApiFp(this.configuration)
      .imagesRegistryGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List importing images
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public listImportingImages(options?: any) {
    return ImagesApiFp(this.configuration)
      .listImportingImages(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get public images
   * @param {string} [filter]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public publicImagesGet(filter?: string, page?: number, pageSize?: number, options?: any) {
    return ImagesApiFp(this.configuration)
      .publicImagesGet(filter, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get public project info
   * @param {string} [filter]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public publicImagesInfoGet(filter?: string, options?: any) {
    return ImagesApiFp(this.configuration)
      .publicImagesInfoGet(filter, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LogsApi - axios parameter creator
 * @export
 */
export const LogsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary get container log
     * @param {string} podName pod name in kubernetes
     * @param {string} [containerName] container name in kubernetes
     * @param {number} [tailLines] tail lines of the log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContainerLog: async (
      podName: string,
      containerName?: string,
      tailLines?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'podName' is not null or undefined
      assertParamExists('getContainerLog', 'podName', podName);
      const localVarPath = `/log/pod/{pod_name}`.replace(
        `{${'pod_name'}}`,
        encodeURIComponent(String(podName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (containerName !== undefined) {
        localVarQueryParameter['container_name'] = containerName;
      }

      if (tailLines !== undefined) {
        localVarQueryParameter['tail_lines'] = tailLines;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LogsApi - functional programming interface
 * @export
 */
export const LogsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LogsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary get container log
     * @param {string} podName pod name in kubernetes
     * @param {string} [containerName] container name in kubernetes
     * @param {number} [tailLines] tail lines of the log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContainerLog(
      podName: string,
      containerName?: string,
      tailLines?: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getContainerLog(
        podName,
        containerName,
        tailLines,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * LogsApi - factory interface
 * @export
 */
export const LogsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LogsApiFp(configuration);
  return {
    /**
     *
     * @summary get container log
     * @param {string} podName pod name in kubernetes
     * @param {string} [containerName] container name in kubernetes
     * @param {number} [tailLines] tail lines of the log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContainerLog(
      podName: string,
      containerName?: string,
      tailLines?: number,
      options?: any,
    ): AxiosPromise<any> {
      return localVarFp
        .getContainerLog(podName, containerName, tailLines, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LogsApi - object-oriented interface
 * @export
 * @class LogsApi
 * @extends {BaseAPI}
 */
export class LogsApi extends BaseAPI {
  /**
   *
   * @summary get container log
   * @param {string} podName pod name in kubernetes
   * @param {string} [containerName] container name in kubernetes
   * @param {number} [tailLines] tail lines of the log
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LogsApi
   */
  public getContainerLog(
    podName: string,
    containerName?: string,
    tailLines?: number,
    options?: any,
  ) {
    return LogsApiFp(this.configuration)
      .getContainerLog(podName, containerName, tailLines, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ReleasesApi - axios parameter creator
 * @export
 */
export const ReleasesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create a release
     * @param {string} name release name
     * @param {ReleaseCreateConfig} [releaseCreateConfig]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRelease: async (
      name: string,
      releaseCreateConfig?: ReleaseCreateConfig,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('createRelease', 'name', name);
      const localVarPath = `/releases/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        releaseCreateConfig,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a release
     * @param {string} name release name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRelease: async (name: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deleteRelease', 'name', name);
      const localVarPath = `/releases/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get information from specific release
     * @param {string} name release name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRelease: async (name: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getRelease', 'name', name);
      const localVarPath = `/releases/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ReleasesApi - functional programming interface
 * @export
 */
export const ReleasesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ReleasesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create a release
     * @param {string} name release name
     * @param {ReleaseCreateConfig} [releaseCreateConfig]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRelease(
      name: string,
      releaseCreateConfig?: ReleaseCreateConfig,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createRelease(
        name,
        releaseCreateConfig,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete a release
     * @param {string} name release name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRelease(
      name: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRelease(name, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get information from specific release
     * @param {string} name release name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRelease(
      name: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRelease(name, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * ReleasesApi - factory interface
 * @export
 */
export const ReleasesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ReleasesApiFp(configuration);
  return {
    /**
     *
     * @summary Create a release
     * @param {string} name release name
     * @param {ReleaseCreateConfig} [releaseCreateConfig]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRelease(
      name: string,
      releaseCreateConfig?: ReleaseCreateConfig,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .createRelease(name, releaseCreateConfig, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a release
     * @param {string} name release name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRelease(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deleteRelease(name, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get information from specific release
     * @param {string} name release name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRelease(name: string, options?: any): AxiosPromise<InlineResponse2001> {
      return localVarFp.getRelease(name, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * ReleasesApi - object-oriented interface
 * @export
 * @class ReleasesApi
 * @extends {BaseAPI}
 */
export class ReleasesApi extends BaseAPI {
  /**
   *
   * @summary Create a release
   * @param {string} name release name
   * @param {ReleaseCreateConfig} [releaseCreateConfig]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReleasesApi
   */
  public createRelease(name: string, releaseCreateConfig?: ReleaseCreateConfig, options?: any) {
    return ReleasesApiFp(this.configuration)
      .createRelease(name, releaseCreateConfig, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a release
   * @param {string} name release name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReleasesApi
   */
  public deleteRelease(name: string, options?: any) {
    return ReleasesApiFp(this.configuration)
      .deleteRelease(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get information from specific release
   * @param {string} name release name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReleasesApi
   */
  public getRelease(name: string, options?: any) {
    return ReleasesApiFp(this.configuration)
      .getRelease(name, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * StorageApi - axios parameter creator
 * @export
 */
export const StorageApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create directory
     * @param {string} path File or Directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDirectory: async (path: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('createDirectory', 'path', path);
      const localVarPath = `/storage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (path !== undefined) {
        localVarQueryParameter['path'] = path;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete directory or file
     * @param {string} path Directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDirectoryOrFile: async (path: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('deleteDirectoryOrFile', 'path', path);
      const localVarPath = `/storage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (path !== undefined) {
        localVarQueryParameter['path'] = path;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get directory
     * @param {string} [path] Directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDirectory: async (path?: string, options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/storage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (path !== undefined) {
        localVarQueryParameter['path'] = path;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Download File
     * @param {string} path Source path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storageDownloadGet: async (path: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('storageDownloadGet', 'path', path);
      const localVarPath = `/storage/download`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (path !== undefined) {
        localVarQueryParameter['path'] = path;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Upload File
     * @param {string} [path] Destination directory
     * @param {any} [file] file type for upload and Download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storageUploadPost: async (
      path?: string,
      file?: any,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/storage/upload`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      if (path !== undefined) {
        localVarQueryParameter['path'] = path;
      }

      if (file !== undefined) {
        localVarFormParams.append('file', file as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StorageApi - functional programming interface
 * @export
 */
export const StorageApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StorageApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create directory
     * @param {string} path File or Directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDirectory(
      path: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDirectory(path, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete directory or file
     * @param {string} path Directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteDirectoryOrFile(
      path: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDirectoryOrFile(
        path,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get directory
     * @param {string} [path] Directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDirectory(
      path?: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileInfo>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDirectory(path, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Download File
     * @param {string} path Source path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storageDownloadGet(
      path: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storageDownloadGet(path, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Upload File
     * @param {string} [path] Destination directory
     * @param {any} [file] file type for upload and Download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storageUploadPost(
      path?: string,
      file?: any,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storageUploadPost(
        path,
        file,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * StorageApi - factory interface
 * @export
 */
export const StorageApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = StorageApiFp(configuration);
  return {
    /**
     *
     * @summary Create directory
     * @param {string} path File or Directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDirectory(path: string, options?: any): AxiosPromise<void> {
      return localVarFp.createDirectory(path, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete directory or file
     * @param {string} path Directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDirectoryOrFile(path: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteDirectoryOrFile(path, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get directory
     * @param {string} [path] Directory path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDirectory(path?: string, options?: any): AxiosPromise<Array<FileInfo>> {
      return localVarFp.getDirectory(path, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Download File
     * @param {string} path Source path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storageDownloadGet(path: string, options?: any): AxiosPromise<any> {
      return localVarFp
        .storageDownloadGet(path, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Upload File
     * @param {string} [path] Destination directory
     * @param {any} [file] file type for upload and Download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storageUploadPost(path?: string, file?: any, options?: any): AxiosPromise<void> {
      return localVarFp
        .storageUploadPost(path, file, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * StorageApi - object-oriented interface
 * @export
 * @class StorageApi
 * @extends {BaseAPI}
 */
export class StorageApi extends BaseAPI {
  /**
   *
   * @summary Create directory
   * @param {string} path File or Directory path
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageApi
   */
  public createDirectory(path: string, options?: any) {
    return StorageApiFp(this.configuration)
      .createDirectory(path, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete directory or file
   * @param {string} path Directory path
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageApi
   */
  public deleteDirectoryOrFile(path: string, options?: any) {
    return StorageApiFp(this.configuration)
      .deleteDirectoryOrFile(path, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get directory
   * @param {string} [path] Directory path
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageApi
   */
  public getDirectory(path?: string, options?: any) {
    return StorageApiFp(this.configuration)
      .getDirectory(path, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Download File
   * @param {string} path Source path
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageApi
   */
  public storageDownloadGet(path: string, options?: any) {
    return StorageApiFp(this.configuration)
      .storageDownloadGet(path, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Upload File
   * @param {string} [path] Destination directory
   * @param {any} [file] file type for upload and Download
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageApi
   */
  public storageUploadPost(path?: string, file?: any, options?: any) {
    return StorageApiFp(this.configuration)
      .storageUploadPost(path, file, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/user/info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary init user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userInitPost: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/user/init`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get user task info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userTasksGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/user/tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      await setApiKeyToObject(localVarHeaderParameter, 'Authorization', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary init user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userInitPost(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userInitPost(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary get user task info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userTasksGet(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTasksInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userTasksGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     *
     * @summary Get user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(options?: any): AxiosPromise<UserInfo> {
      return localVarFp.getUser(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary init user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userInitPost(options?: any): AxiosPromise<void> {
      return localVarFp.userInitPost(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary get user task info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userTasksGet(options?: any): AxiosPromise<UserTasksInfo> {
      return localVarFp.userTasksGet(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   *
   * @summary Get user info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUser(options?: any) {
    return UsersApiFp(this.configuration)
      .getUser(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary init user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public userInitPost(options?: any) {
    return UsersApiFp(this.configuration)
      .userInitPost(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary get user task info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public userTasksGet(options?: any) {
    return UsersApiFp(this.configuration)
      .userTasksGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}
